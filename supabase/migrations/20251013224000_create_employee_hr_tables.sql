-- migration: create employee and hr support tables
-- purpose: establish core employee-facing entities (departments, employees, attendance, leave requests, salary history, performance evaluations)
-- considerations: enables row level security and policies for per-user data segregation; includes helper trigger to maintain updated_at columns

begin;

-- create helper function to auto-manage updated_at timestamps
create or replace function public.handle_updated_at()
returns trigger
language plpgsql
security invoker
set search_path = ''
as $$
begin
  new.updated_at := now();
  return new;
end;
$$;

-- departments catalog
create table if not exists public.departments (
  id bigint generated by default as identity primary key,
  name text not null unique,
  description text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create trigger set_departments_updated_at
before update on public.departments
for each row
execute function public.handle_updated_at();

-- employees directory linked to auth.users
create table if not exists public.employees (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  employee_id text not null unique,
  first_name text not null,
  last_name text not null,
  email text not null unique,
  date_of_birth date,
  date_of_joining date not null,
  department_id bigint references public.departments (id) on delete set null,
  position text,
  phone text,
  address text,
  emergency_contact_name text,
  emergency_contact_phone text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create trigger set_employees_updated_at
before update on public.employees
for each row
execute function public.handle_updated_at();

-- add manager linkage now that employees table exists
alter table public.departments
  add column if not exists manager_id bigint references public.employees (id) on delete set null;

create index if not exists employees_user_idx on public.employees using btree (user_id);
create index if not exists employees_department_idx on public.employees using btree (department_id);

-- attendance records per employee per day
create table if not exists public.attendance_records (
  id bigint generated by default as identity primary key,
  employee_id bigint not null references public.employees (id) on delete cascade,
  date date not null,
  check_in_time timestamptz,
  check_out_time timestamptz,
  break_duration_minutes integer default 0,
  total_hours numeric(5,2),
  status text not null check (status in ('present', 'absent', 'partial', 'holiday', 'sick')),
  notes text,
  created_at timestamptz not null default now()
);

create unique index if not exists attendance_unique_employee_date
  on public.attendance_records (employee_id, date);

create index if not exists attendance_employee_idx on public.attendance_records using btree (employee_id);

-- leave requests with approval metadata
create table if not exists public.leave_requests (
  id bigint generated by default as identity primary key,
  employee_id bigint not null references public.employees (id) on delete cascade,
  leave_type text not null check (leave_type in ('vacation', 'sick', 'personal', 'emergency', 'maternity', 'paternity')),
  start_date date not null,
  end_date date not null,
  days_requested integer not null check (days_requested > 0),
  reason text,
  status text not null default 'pending' check (status in ('pending', 'approved', 'rejected')),
  approved_by bigint references public.employees (id) on delete set null,
  approved_at timestamptz,
  rejection_reason text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create trigger set_leave_requests_updated_at
before update on public.leave_requests
for each row
execute function public.handle_updated_at();

create index if not exists leave_requests_employee_idx on public.leave_requests using btree (employee_id);
create index if not exists leave_requests_status_idx on public.leave_requests using btree (status);

-- salary history tracking
create table if not exists public.salary_records (
  id bigint generated by default as identity primary key,
  employee_id bigint not null references public.employees (id) on delete cascade,
  base_salary numeric(12,2) not null,
  effective_date date not null,
  salary_type text not null default 'monthly' check (salary_type in ('monthly', 'annual')),
  currency text not null default 'USD',
  created_at timestamptz not null default now()
);

create unique index if not exists salary_unique_employee_effective
  on public.salary_records (employee_id, effective_date);

create index if not exists salary_employee_idx on public.salary_records using btree (employee_id);

-- performance evaluation snapshots
create table if not exists public.performance_evaluations (
  id bigint generated by default as identity primary key,
  employee_id bigint not null references public.employees (id) on delete cascade,
  evaluation_period_start date not null,
  evaluation_period_end date not null,
  overall_rating numeric(3,2) not null check (overall_rating between 1.0 and 5.0),
  performance_score numeric(6,2),
  goals_achieved integer,
  total_goals integer,
  evaluator_id bigint references public.employees (id) on delete set null,
  comments text,
  salary_adjustment_percentage numeric(6,2),
  bonus_amount numeric(12,2),
  created_at timestamptz not null default now()
);

create index if not exists performance_employee_idx on public.performance_evaluations using btree (employee_id);

-- enable row level security across tables handling user data
alter table public.departments enable row level security;
alter table public.employees enable row level security;
alter table public.attendance_records enable row level security;
alter table public.leave_requests enable row level security;
alter table public.salary_records enable row level security;
alter table public.performance_evaluations enable row level security;

-- departments can be viewed by any authenticated user to display names
create policy "departments viewable to authenticated users"
  on public.departments
  for select
  to authenticated
  using (true);

-- employees policies restricting to record owner
create policy "employees selectable by owner"
  on public.employees
  for select
  to authenticated
  using (
    (select auth.uid()) = user_id
  );

create policy "employees insertable by owner"
  on public.employees
  for insert
  to authenticated
  with check (
    (select auth.uid()) = user_id
  );

create policy "employees updatable by owner"
  on public.employees
  for update
  to authenticated
  using (
    (select auth.uid()) = user_id
  )
  with check (
    (select auth.uid()) = user_id
  );

-- attendance records policies scoped to employee owner
create policy "attendance selectable by owner"
  on public.attendance_records
  for select
  to authenticated
  using (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  );

create policy "attendance insertable by owner"
  on public.attendance_records
  for insert
  to authenticated
  with check (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  );

create policy "attendance updatable by owner"
  on public.attendance_records
  for update
  to authenticated
  using (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  )
  with check (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  );

-- leave requests policies
create policy "leave selectable by owner"
  on public.leave_requests
  for select
  to authenticated
  using (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  );

create policy "leave insertable by owner"
  on public.leave_requests
  for insert
  to authenticated
  with check (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  );

create policy "leave updatable by owner"
  on public.leave_requests
  for update
  to authenticated
  using (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  )
  with check (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  );

-- salary records policies
create policy "salary selectable by owner"
  on public.salary_records
  for select
  to authenticated
  using (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  );

create policy "salary insertable by owner"
  on public.salary_records
  for insert
  to authenticated
  with check (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  );

create policy "salary updatable by owner"
  on public.salary_records
  for update
  to authenticated
  using (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  )
  with check (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  );

-- performance evaluations policies
create policy "performance selectable by owner"
  on public.performance_evaluations
  for select
  to authenticated
  using (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  );

create policy "performance insertable by owner"
  on public.performance_evaluations
  for insert
  to authenticated
  with check (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  );

create policy "performance updatable by owner"
  on public.performance_evaluations
  for update
  to authenticated
  using (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  )
  with check (
    employee_id in (
      select e.id from public.employees e where e.user_id = (select auth.uid())
    )
  );

commit;
